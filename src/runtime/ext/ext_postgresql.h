/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   | Copyright (c) 1997-2010 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/

#ifndef __EXT_POSTGRESQL_H__
#define __EXT_POSTGRESQL_H__

// >>>>>> Generated by idl.php. Do NOT modify. <<<<<<

#include <runtime/base/base_includes.h>
#include <postgresql/libpq-fe.h>
// do we need postgresql/catalog/pg_type.h?
#include <postgresql/pg_config.h>

#define POSTGRESQL_PORT 5432
#define POSTGRESQL_UNIX_ADDR 5432

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////

class Postgresql : public SweepableResourceData {
public:
  /**
   * Operations on a resource object.
   */
  static PGconn *GetConn(CVarRef link_identifier, Postgresql **rconn = NULL);
  static Postgresql *Get(CVarRef link_identifier);
  static bool CloseConn(CVarRef link_identifier);

  String GetTypeName(Oid oid);
  /**
   * Default settings.
   */
  static String GetDefaultServer()   { return String();}
  static int GetDefaultPort();
  static String GetDefaultSocket();
  static String GetDefaultUsername() { return String();}
  static String GetDefaultPassword() { return String();}
  static String GetDefaultDatabase() { return String();}

  /**
   * A connection may be persistent across multiple HTTP requests.
   */
  static Postgresql *GetPersistent(CStrRef dsn) {
    return GetCachedImpl("postgresql::persistent_conns", dsn);
  }

  static void SetPersistent(CStrRef dsn, Postgresql *conn) {
    SetCachedImpl("postgresql::persistent_conns", dsn, conn);
  }

  /**
   * If connection object is not provided, a default connection will be used.
   */
  static Postgresql *GetDefaultConn();
  static void SetDefaultConn(Postgresql *conn);

private:
  static int s_default_port;

  static String GetHash(CStrRef dsn);

  static Postgresql *GetCachedImpl(const char *name, CStrRef dsn);

  static void SetCachedImpl(const char *name, CStrRef dsn, Postgresql *conn);
  std::map<Oid, String> m_types;
  bool m_type_map_loaded;
  void load_type_map();
public:
  Postgresql(const char *dsn);
  ~Postgresql();
  void setLastError(const char *func);
  void close();

  static StaticString s_class_name;
  // overriding ResourceData
  virtual CStrRef o_getClassName() const { return s_class_name; }
  virtual bool isResource() const { return m_conn != NULL;}

  bool connect(CStrRef dsn);
  bool reconnect(CStrRef dsn);

  PGconn *get() { return m_conn;}

private:
  PGconn *m_conn;

public:
  std::string m_host;
  int m_port;
  std::string m_username;
  std::string m_password;
  std::string m_database;
  std::string m_dsn;
  bool m_last_error_set;
  int m_last_errno;
  std::string m_last_error;
  int m_xaction_count;
};

///////////////////////////////////////////////////////////////////////////////


class PostgresqlResult : public SweepableResourceData {
public:
  DECLARE_OBJECT_ALLOCATION(PostgresqlResult);

  PostgresqlResult(PGresult *res);
  virtual ~PostgresqlResult();
  int64 nextRow();
  int64 numRows();
  int64 numFields();
  static StaticString s_class_name;
  // overriding ResourceData
  virtual CStrRef o_getClassName() const { return s_class_name; }

  void close() {
    if (m_res) {
      PQclear(m_res);
      m_res = NULL;
    }
  }

  PGresult *get() {
    return m_res;
  }

  void addRow();

  void addField(Variant *value);

  void setFieldCount(int64 fields);

  /**
   * Gets the field content. 
   */
  Variant getField(int64 field) const;

  int64 getFieldCount() const;

  int64 getRowCount() const;

  int64 nextRow() const;

  bool seekRow(CVarRef row);

  bool fetchRow();

  bool seekField(int64 field);

protected:
  PGresult *m_res;

  int64 m_current_row_num;
  bool m_row_ready; // set to false after seekRow, true after fetchRow
  int64 m_field_count;
  int64 m_row_count;
};
///////////////////////////////////////////////////////////////////////////////

int64 f_pg_affected_rows(CVarRef result);
void f_pg_cancel_query(CVarRef connection);
void f_pg_client_encoding(CStrRef connection);
void f_pg_close(CVarRef connection);
Variant f_pg_connect(CStrRef connection_string, int connect_type = 1);
void f_pg_connection_busy(CVarRef connection);
void f_pg_connection_reset(CVarRef connection);
void f_pg_connection_status(CVarRef connection);
void f_pg_convert(CVarRef connection, CStrRef table_name, CStrRef assoc_array, CStrRef options);
void f_pg_copy_from(CVarRef connection, CStrRef table_name, CStrRef rows, CStrRef delimiter, CStrRef null_as);
void f_pg_copy_to(CVarRef connection, CStrRef table_name, CStrRef rows, CStrRef delimiter, CStrRef null_as);
void f_pg_dbname(CStrRef connection);
void f_pg_delete(CVarRef connection, CStrRef table_name, CStrRef assoc_array, CStrRef options);
void f_pg_end_copy(CVarRef connection);
Variant f_pg_escape_bytea(CVarRef connection, CStrRef data);
Variant f_pg_escape_string(CVarRef connection, CStrRef data);
void f_pg_execute(CVarRef connection, CStrRef stmtname, CArrRef params);
Variant f_pg_fetch_all_columns(CVarRef result, CStrRef column);
Variant f_pg_fetch_all(CVarRef result);
Variant f_pg_fetch_array(CVarRef result, CVarRef row = null, int result_type = 3);
Variant f_pg_fetch_assoc(CVarRef result, CVarRef row = null);
Variant f_pg_fetch_object(CVarRef result, CVarRef row = null, CStrRef class_name = null, CVarRef params = null);
Variant f_pg_fetch_result(CVarRef result, int64 row, CStrRef field);
Variant f_pg_fetch_row(CVarRef result, CVarRef row = null);
Variant f_pg_field_is_null(CVarRef result, int64 row, CStrRef field);
String f_pg_field_name(CVarRef result, int64 field_number);
Variant f_pg_field_num(CVarRef result, CStrRef field_name);
Variant f_pg_field_prtlen(CVarRef result, CVarRef field_name_or_number);
Variant f_pg_field_size(CVarRef result, int64 field_number);
String f_pg_field_table(CVarRef result, int64 field_number, CStrRef oid_only);
 String f_pg_field_type_oid(CVarRef result, int64 field_number);
String f_pg_field_type(CVarRef result, int64 field_number);
Variant f_pg_free_result(CVarRef result);
Variant f_pg_get_notify(CVarRef connection, int result_type);
String f_pg_get_pid(CVarRef connection);
Variant f_pg_get_result(CVarRef connection);
String f_pg_host(CVarRef connection);
Variant f_pg_insert(CVarRef connection, CStrRef table_name, CStrRef assoc_array, CStrRef options);
String f_pg_last_error(CVarRef connection);
String f_pg_last_notice(CVarRef connection);
String f_pg_last_oid(CVarRef result);
Variant f_pg_lo_close(CVarRef result);
Variant f_pg_lo_create(CVarRef connection, CStrRef object_id);
Variant f_pg_lo_export(CVarRef connection, CStrRef oid, CStrRef pathname);
Variant f_pg_lo_import(CVarRef connection, CStrRef pathname, CStrRef object_id);
Variant f_pg_lo_open(CVarRef connection, CStrRef oid, CStrRef mode);
Variant f_pg_lo_read_all(CStrRef large_object);
Variant f_pg_lo_read(CStrRef large_object, CStrRef len);
Variant f_pg_lo_seek(CStrRef large_object, CStrRef offset, CStrRef whence);
Variant f_pg_lo_tell(CStrRef large_object);
Variant f_pg_lo_unlink(CVarRef connection, CStrRef oid);
Variant f_pg_lo_write(CStrRef large_object, CStrRef data, CStrRef len);
Variant f_pg_meta_data(CVarRef connection, CStrRef table_name);
Variant f_pg_num_fields(CVarRef result);
Variant f_pg_num_rows(CVarRef result);
Variant f_pg_options(CVarRef connection);
String f_pg_parameter_status(CVarRef connection, CStrRef param_name);
Variant f_pg_pconnect(CStrRef connection_string, CStrRef host, CStrRef hostaddr, CStrRef port, CStrRef dbname, CStrRef user, CStrRef password, CStrRef connect_timeout, CStrRef options, CStrRef tty, CStrRef sslmode, CStrRef requiressl, CStrRef service, CStrRef connect_type);
Variant f_pg_ping(CVarRef connection);
Variant f_pg_port(CVarRef connection);
Variant f_pg_prepare(CVarRef connection, CStrRef stmtname, CStrRef query);
Variant f_pg_put_line(CVarRef connection, CStrRef data);
Variant f_pg_query_params(CVarRef connection, CStrRef query, CArrRef params);
Variant f_pg_query(CVarRef connection, CStrRef query);
Variant f_pg_result_error_field(CVarRef result, CStrRef fieldcode);
Variant f_pg_result_error(CVarRef result);
Variant f_pg_result_seek(CVarRef result, CStrRef offset);
Variant f_pg_result_status(CVarRef result, int64 type = 1);
Variant f_pg_select(CVarRef connection, CStrRef table_name, CStrRef assoc_array, CStrRef options);
Variant f_pg_send_execute(CVarRef connection, CStrRef stmtname, CArrRef params);
Variant f_pg_send_prepare(CVarRef connection, CStrRef stmtname, CStrRef query);
Variant f_pg_send_query_params(CVarRef connection, CStrRef query, CArrRef params);
Variant f_pg_send_query(CVarRef connection, CStrRef query);
Variant f_pg_set_client_encoding(CVarRef connection, CStrRef encoding);
Variant f_pg_set_error_verbosity(CVarRef connection, CStrRef verbosity);
bool f_pg_trace(CStrRef pathname, CStrRef mode = "w", CVarRef connection = null);
int f_pg_transaction_status(CVarRef connection);
String f_pg_tty(CVarRef connection);
String f_pg_unescape_bytea(CStrRef data);
bool f_pg_untrace(CVarRef connection);
Variant f_pg_update(CVarRef connection, CStrRef table_name, CVarRef data, CVarRef condition, int options);
Variant f_pg_version(CVarRef connection);
extern const int64 k_PGSQL_ASSOC;
extern const int64 k_PGSQL_NUM;
extern const int64 k_PGSQL_BOTH;
extern const int64 k_PGSQL_CONNECT_FORCE_NEW;
extern const int64 k_PGSQL_CONNECTION_BAD;
extern const int64 k_PGSQL_CONNECTION_OK;
extern const int64 k_PGSQL_SEEK_SET;
extern const int64 k_PGSQL_SEEK_CUR;
extern const int64 k_PGSQL_SEEK_END;
extern const int64 k_PGSQL_EMPTY_QUERY;
extern const int64 k_PGSQL_COMMAND_OK;
extern const int64 k_PGSQL_TUPLES_OK;
extern const int64 k_PGSQL_COPY_OUT;
extern const int64 k_PGSQL_COPY_IN;
extern const int64 k_PGSQL_BAD_RESPONSE;
extern const int64 k_PGSQL_NONFATAL_ERROR;
extern const int64 k_PGSQL_FATAL_ERROR;
extern const int64 k_PGSQL_TRANSACTION_IDLE;
extern const int64 k_PGSQL_TRANSACTION_ACTIVE;
extern const int64 k_PGSQL_TRANSACTION_INTRANS;
extern const int64 k_PGSQL_TRANSACTION_INERROR;
extern const int64 k_PGSQL_TRANSACTION_UNKNOWN;
extern const int64 k_PGSQL_DIAG_SEVERITY;
extern const int64 k_PGSQL_DIAG_SQLSTATE;
extern const int64 k_PGSQL_DIAG_MESSAGE_PRIMARY;
extern const int64 k_PGSQL_DIAG_MESSAGE_DETAIL;
extern const int64 k_PGSQL_DIAG_MESSAGE_HINT;
extern const int64 k_PGSQL_DIAG_STATEMENT_POSITION;
extern const int64 k_PGSQL_DIAG_INTERNAL_POSITION;
extern const int64 k_PGSQL_DIAG_INTERNAL_QUERY;
extern const int64 k_PGSQL_DIAG_CONTEXT;
extern const int64 k_PGSQL_DIAG_SOURCE_FILE;
extern const int64 k_PGSQL_DIAG_SOURCE_LINE;
extern const int64 k_PGSQL_DIAG_SOURCE_FUNCTION;
extern const int64 k_PGSQL_ERRORS_TERSE;
extern const int64 k_PGSQL_ERRORS_DEFAULT;
extern const int64 k_PGSQL_ERRORS_VERBOSE;
extern const int64 k_PGSQL_STATUS_LONG;
extern const int64 k_PGSQL_STATUS_STRING;
extern const int64 k_PGSQL_CONV_IGNORE_DEFAULT;
extern const int64 k_PGSQL_CONV_FORCE_NULL;
extern const int64 k_PGSQL_CONV_IGNORE_DEFAULT;

///////////////////////////////////////////////////////////////////////////////
}

#endif // __EXT_POSTGRESQL_H__
